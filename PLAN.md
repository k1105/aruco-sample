# ArUco Web-Based Position Estimation System - 実行計画

## 1. プロジェクト概要

### 1.1 目的

複数台のiPadからWebブラウザ経由でArUcoマーカーを検出し、各端末の自己位置（カメラ姿勢）を推定する。推定された位置情報を元に、マーカー位置を基準に配置された仮想立方体オブジェクトを各端末の視点からレンダリングする。

### 1.2 フェーズ定義

| フェーズ | 内容 | 状態 |
|---------|------|------|
| Phase 1（今回） | 単一端末でのマーカー検出・姿勢推定・立方体レンダリング | 対象 |
| Phase 2（将来） | 複数端末間での座標系共有と同一オブジェクトの多視点表示 | 計画のみ |

### 1.3 アプリケーションモード

- **キャリブレーションモード**: カメラ映像からArUcoマーカーを検出し、端末のカメラ姿勢（位置・回転）をリアルタイムに推定・表示する
- **パフォーマンスモード**: 推定されたカメラ姿勢を用いて、仮想空間上の立方体オブジェクトを端末視点からレンダリングした3D映像を表示する（カメラ映像は表示しない）

---

## 2. マーカー戦略

### 2.1 マーカータイプの選定: ArUco vs ChArUco

| 観点 | ArUco | ChArUco |
|------|-------|---------|
| 検出単位 | 個別マーカー（1枚ずつ独立） | チェスボード＋ArUcoの複合ボード |
| 主用途 | 姿勢推定（solvePnP） | カメラ内部パラメータのキャリブレーション |
| 部分遮蔽への耐性 | 1枚のマーカーが完全に見える必要あり | 一部が隠れても残りの角から推定可能 |
| 立体支持体への適合性 | 各面に1枚ずつ配置可能 | ボードが大きく、立体面への配置に不向き |
| 検出速度 | 高速 | やや遅い（チェスボード角検出を含む） |

**結論: ArUcoマーカーを採用する**

理由:
1. 立体支持体の各面に独立したマーカーを配置する設計との相性が良い
2. solvePnPによる姿勢推定には、1枚のマーカーの4角で十分
3. 検出速度が速く、リアルタイム処理に適する
4. カメラの内部パラメータ（焦点距離等）については、iPadの既知パラメータを初期値として使用し、オプションでChArUcoボードによるキャリブレーションを実装する

### 2.2 マーカー辞書

**`DICT_4X4_50`** を採用する。

- 4x4ビットのマーカー（最小サイズ）で、遠距離からの検出に有利
- 50種類のIDがあり、立方体の5面に十分
- 誤検出率が低い（ハミング距離による誤り訂正）

### 2.3 物理的なマーカー支持体の設計

#### 推奨構成: 立方体支持体（5面マーカー）

```
        ┌────────────┐
        │  ID: 1     │  ← 上面（Top）
        │  (top)     │
   ┌────┼────────────┼────┬────────────┐
   │ID:4│            │ID:2│            │
   │left│            │rght│            │
   └────┼────────────┼────┴────────────┘
        │  ID: 0     │  ← 正面（Front）
        │  (front)   │
        ├────────────┤
        │  ID: 3     │  ← 背面（Back）
        │  (back)    │
        └────────────┘
        （底面にはマーカーなし）
```

#### なぜ立方体なのか

1. **全方位からの視認性**: iPadが立方体の周囲にどの角度で配置されても、少なくとも1〜2面のマーカーが視認可能
2. **面間の幾何学的関係が既知**: 各面のマーカーの3D座標が立方体の寸法から一意に決まる
3. **座標系の基準が明確**: 立方体の中心を原点とした世界座標系を自然に定義できる
4. **斜め方向からの視認**: 平面マーカー1枚の場合、浅い角度からの検出が困難だが、立方体なら側面のマーカーで補完できる

#### 平面マーカーが不適切な理由

- iPadが水平面に対して斜め〜水平に近い角度で配置される場合、平面マーカーは画像上で非常に細く潰れて見え、検出精度が大幅に低下する
- 複数台のiPadが異なる方向から同一マーカーを見る構成では、全端末にとって良好な検出角度を確保することが困難

### 2.4 物理寸法

| 項目 | 推奨値 | 理由 |
|------|--------|------|
| 立方体の一辺 | **12cm** | テーブル上で十分な存在感がありつつ、持ち運びやすいサイズ |
| マーカーの一辺 | **9cm** | 立方体の面（12cm）に対して、上下左右1.5cmの余白を確保 |
| 余白（白枠） | 1.5cm | ArUcoの検出に必要な白い境界領域 |
| 検出想定距離 | 30cm〜150cm | iPad利用時の一般的な距離 |

#### マーカーの印刷・貼付

- 各マーカーはA4用紙に印刷し、9cm角に切り出す
- 立方体は段ボールや発泡スチロールで作成（12cm角）
- 各面の中央にマーカーを糊で貼付
- **重要**: マーカーの向き（上方向）を統一すること

### 2.5 座標系の定義

```
         Y (上)
         │
         │
         │
         ┼──────── X (右)
        ╱
       ╱
      Z (手前)
```

- 原点: 立方体の中心
- X軸: 正面から見て右方向
- Y軸: 上方向
- Z軸: 正面から見て手前方向
- 単位: メートル（OpenCVの慣例に準拠）

各マーカーの3D座標（マーカー中心が面の中心にある場合）:

| マーカーID | 面 | 法線方向 | マーカー中心座標 (m) |
|-----------|-----|---------|---------------------|
| 0 | 正面 (Front) | +Z | (0, 0, 0.06) |
| 1 | 上面 (Top) | +Y | (0, 0.06, 0) |
| 2 | 右面 (Right) | +X | (0.06, 0, 0) |
| 3 | 背面 (Back) | -Z | (0, 0, -0.06) |
| 4 | 左面 (Left) | -X | (-0.06, 0, 0) |

---

## 3. 技術スタック

### 3.1 概要

| レイヤー | 技術 | バージョン | 用途 |
|---------|------|-----------|------|
| フレームワーク | Next.js | 16.1.x（既存） | SPA基盤、ルーティング |
| UI | React | 19.x（既存） | コンポーネント管理 |
| マーカー検出 | OpenCV.js | 4.10.0 | ArUco検出、solvePnP |
| 3Dレンダリング | Three.js | 最新安定版 | 仮想立方体の描画 |
| カメラアクセス | MediaDevices API | ブラウザ標準 | カメラストリーム取得 |
| 言語 | TypeScript | 5.x（既存） | 型安全性 |

### 3.2 OpenCV.js のロード戦略

OpenCV.jsは約8MBのファイルであるため、以下の戦略を取る:

1. CDN（jsdelivr）から非同期ロード
2. `<script>` タグの `async` 属性で非同期読み込み
3. `cv.onRuntimeInitialized` でロード完了を検知
4. ロード中はローディングインジケータを表示

```
// ロード元
https://cdn.jsdelivr.net/npm/opencv.js@4.10.0/opencv.js
```

> **注意**: OpenCV.jsにはArUcoモジュールが含まれるビルドと含まれないビルドがある。ArUcoモジュール入りのビルドを使用する必要がある。公式CDN版に含まれない場合は、カスタムビルドまたは `@sinonjs/opencv-js` 等の代替パッケージを検討する。js-arucoのようなピュアJSライブラリも代替候補。

### 3.3 OpenCV.js ArUco対応に関する補足

opencv.jsの標準ビルドにはArUcoモジュールが含まれない場合がある。以下の選択肢を検討する:

| 選択肢 | 長所 | 短所 |
|--------|------|------|
| opencv.jsカスタムビルド（ArUco含む） | フル機能、solvePnP含む | ビルドが複雑、ファイルサイズ大 |
| js-aruco / ar.js 等のピュアJSライブラリ | 軽量、導入が容易 | solvePnPが別途必要 |
| 参考記事と同様のopencv.jsビルド | 実績あり | バージョン固定 |

**推奨**: 参考記事で使用されているopencv.jsビルド（ArUco対応版）をまず試し、問題があればカスタムビルドに切り替える。

---

## 4. アプリケーションアーキテクチャ

### 4.1 ページ構成

```
app/
├── layout.tsx                  # 共通レイアウト（メタデータ、viewport、iPad対応）
├── providers.tsx               # クライアント側プロバイダー統合（OpenCV + Pose）
├── page.tsx                    # トップページ（モード選択）
├── calibration/
│   └── page.tsx                # キャリブレーションモード
├── performance/
│   └── page.tsx                # パフォーマンスモード
└── components/
    ├── Header.tsx              # 共通ヘッダー（戻るボタン + タイトル + アクション）
    ├── CameraView.tsx          # カメラ映像表示＋Canvas＋マーカーオーバーレイ描画
    ├── CubeRenderer.tsx        # Three.jsによる立方体レンダリング
    ├── StatusOverlay.tsx       # 検出状態・姿勢情報の表示パネル
    ├── OpenCVLoader.tsx        # OpenCV.js非同期ロード管理（React Context）
    └── PoseContext.tsx         # 姿勢データのページ間共有（React Context）

lib/
├── types.ts                    # 共有型定義（MarkerDetection, PoseResult等）
└── constants.ts                # マーカー定義、カメラデフォルト値、座標系定数

hooks/（機能実装フェーズで追加）
├── useMarkerDetection.ts       # ArUcoマーカー検出ロジック
└── usePoseEstimation.ts        # solvePnPによる姿勢推定ロジック
```

> **変更点**: MarkerDetector.tsx / PoseEstimator.tsx はUIを持たないロジックのため、
> カスタムフック（hooks/）として実装する方が適切。UIコンポーネントとロジックの分離を明確にする。
> ページ間の姿勢データ共有にはPoseContext（React Context）を使用する。

### 4.2 データフロー

```
┌─────────────────────────────────────────────────────────────────┐
│                    キャリブレーションモード                        │
│                                                                 │
│  Camera Stream ──→ Video Element ──→ Canvas (フレーム取得)       │
│                                          │                      │
│                                          ▼                      │
│                                   OpenCV.js                     │
│                                   ┌─────────────────┐          │
│                                   │ detectMarkers() │          │
│                                   │ estimatePose()   │          │
│                                   │ solvePnP()       │          │
│                                   └────────┬────────┘          │
│                                            │                    │
│                                            ▼                    │
│                                   姿勢データ (rvec, tvec)       │
│                                   ┌─────────────────┐          │
│                                   │ ・回転ベクトル    │          │
│                                   │ ・並進ベクトル    │          │
│                                   │ ・検出マーカーID  │          │
│                                   └────────┬────────┘          │
│                                            │                    │
│                              ┌─────────────┼──────────────┐    │
│                              ▼             ▼              ▼    │
│                         画面表示      State保存    モード切替時  │
│                       (デバッグ情報)  (React State)  に引き継ぎ  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    パフォーマンスモード                           │
│                                                                 │
│  保存された姿勢データ ──→ Three.js カメラ設定                    │
│                                  │                              │
│                                  ▼                              │
│                           Three.js Scene                        │
│                           ┌────────────────┐                   │
│                           │ ・仮想立方体     │                   │
│                           │ ・グリッド/軸    │                   │
│                           │ ・ライティング   │                   │
│                           └───────┬────────┘                   │
│                                   │                             │
│                                   ▼                             │
│                              Canvas出力                         │
│                          (3Dレンダリング結果)                    │
│                                                                 │
│  ※ カメラ映像は表示しない                                       │
│  ※ 将来的にはリアルタイムで姿勢更新を継続する可能性あり          │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 姿勢推定の数学的フロー

```
1. マーカーの4角の画像座標 (2D) を検出
   imagePoints = [(x1,y1), (x2,y2), (x3,y3), (x4,y4)]

2. マーカーの4角の世界座標 (3D) は既知
   objectPoints = [(-s/2,-s/2,0), (s/2,-s/2,0), (s/2,s/2,0), (-s/2,s/2,0)]
   ※ s = マーカーの一辺の長さ (0.09m)
   ※ 各マーカーの座標系は、そのマーカーの面上で定義

3. cv.solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs)
   → rvec (回転ベクトル 3x1), tvec (並進ベクトル 3x1)

4. rvecをRodrigues変換で回転行列 R (3x3) に変換
   cv.Rodrigues(rvec) → R

5. カメラの世界座標系での位置:
   cameraPosition = -R^T * tvec

6. カメラの世界座標系での回転:
   cameraRotation = R^T

7. 複数マーカー検出時は、各マーカーの面の座標系から
   立方体中心座標系への変換を適用してから統合
```

### 4.4 カメラ内部パラメータ

#### 初期値（iPad想定）

iPad のカメラは機種ごとに異なるが、以下を初期値として使用する:

```
カメラ行列 (3x3):
K = [ fx  0   cx ]
    [ 0   fy  cy ]
    [ 0   0   1  ]

想定値（640x480解像度時）:
  fx = fy = 600  (焦点距離、ピクセル単位)
  cx = 320       (画像中心X)
  cy = 240       (画像中心Y)

歪み係数: [0, 0, 0, 0, 0] (初期値はゼロ)
```

#### オプション: ChArUcoによるキャリブレーション

精度向上が必要な場合は、以下のフローでキャリブレーションを実装可能:

1. ChArUcoボード（5x7, 辞書DICT_4X4_50）を画面に表示or印刷
2. 複数角度から撮影（10〜20枚）
3. `cv.calibrateCameraExtended()` で内部パラメータを推定
4. 結果をlocalStorageに保存

---

## 5. 実装タスク

### 5.1 タスク一覧

| # | タスク | 優先度 | 依存 | 見積工数 |
|---|--------|--------|------|---------|
| T1 | プロジェクト基盤整備（依存パッケージ追加、型定義） | 高 | - | - |
| T2 | OpenCV.js ローダーコンポーネント | 高 | T1 | - |
| T3 | カメラアクセス・映像表示コンポーネント | 高 | T1 | - |
| T4 | ArUcoマーカー検出機能 | 高 | T2, T3 | - |
| T5 | solvePnPによる姿勢推定 | 高 | T4 | - |
| T6 | マーカー座標系→立方体中心座標系の変換 | 高 | T5 | - |
| T7 | キャリブレーションモード画面 | 高 | T4, T5, T6 | - |
| T8 | Three.jsによる立方体レンダリング | 中 | T1 | - |
| T9 | パフォーマンスモード画面 | 中 | T7, T8 | - |
| T10 | トップページ（モード選択UI） | 低 | T7, T9 | - |
| T11 | iPad最適化（全画面、タッチ対応） | 低 | T10 | - |
| T12 | (Optional) ChArUcoキャリブレーション | 低 | T4 | - |

### 5.2 タスク詳細

#### T1: プロジェクト基盤整備

```bash
npm install three @types/three
```

- `types/opencv.d.ts` の作成（OpenCV.jsの型定義）
- `next.config.ts` の更新（必要に応じてWebpack設定追加）
- `lib/constants.ts` にマーカー定義（ID、サイズ、座標系）を記述

#### T2: OpenCV.jsローダー

- Reactコンテキストで `cv` オブジェクトをアプリ全体に共有
- ロード状態（loading / ready / error）の管理
- CDNからの `<script>` 動的挿入

#### T3: カメラアクセス

- `navigator.mediaDevices.getUserMedia()` でカメラストリーム取得
- iPadの背面カメラ指定（`facingMode: 'environment'`）
- 解像度指定（640x480 または 1280x720）
- `<video>` 要素へのストリーム設定
- `requestAnimationFrame` ループで `<canvas>` にフレーム描画

#### T4: ArUcoマーカー検出

```typescript
// 疑似コード
const dictionary = cv.getPredefinedDictionary(cv.DICT_4X4_50);
const detectorParams = new cv.DetectorParameters();
const detector = new cv.ArucoDetector(dictionary, detectorParams);

// フレームごとの処理
const gray = new cv.Mat();
cv.cvtColor(frame, gray, cv.COLOR_RGBA2GRAY);
const corners = new cv.MatVector();
const ids = new cv.Mat();
detector.detectMarkers(gray, corners, ids);
```

#### T5: 姿勢推定

```typescript
// 各検出マーカーに対してsolvePnPを実行
const objectPoints = cv.matFromArray(4, 1, cv.CV_32FC3, [
  -markerSize/2,  markerSize/2, 0,
   markerSize/2,  markerSize/2, 0,
   markerSize/2, -markerSize/2, 0,
  -markerSize/2, -markerSize/2, 0,
]);

const rvec = new cv.Mat();
const tvec = new cv.Mat();
cv.solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec);
```

#### T6: 座標変換

各マーカー面の局所座標系から立方体中心の世界座標系への変換行列:

```typescript
// マーカーID 0 (正面, +Z方向) の変換行列例
// マーカー面の法線が+Z方向を向いている場合、
// マーカー座標系→世界座標系の変換:
// T_world_marker0 = Translation(0, 0, 0.06) * Rotation(なし)
//
// マーカーID 2 (右面, +X方向) の場合:
// T_world_marker2 = Translation(0.06, 0, 0) * Rotation(Y軸周り-90度)
```

#### T7: キャリブレーションモード画面

レイアウト:
```
┌────────────────────────────────┐
│  [← Back]  キャリブレーション    │
├────────────────────────────────┤
│                                │
│    カメラ映像 + マーカー検出    │
│    オーバーレイ（軸表示）       │
│                                │
├────────────────────────────────┤
│ 検出マーカー: ID 0, 2          │
│ 位置: x=0.15, y=0.20, z=0.50  │
│ 回転: rx=10°, ry=25°, rz=5°   │
│                                │
│ [パフォーマンスモードへ →]      │
└────────────────────────────────┘
```

#### T8: Three.jsレンダリング

```typescript
// Three.jsシーン構成
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(fov, aspect, 0.01, 100);

// 仮想立方体（原点に配置）
const geometry = new THREE.BoxGeometry(0.12, 0.12, 0.12);
const material = new THREE.MeshStandardMaterial({
  color: 0x4488ff,
  transparent: true,
  opacity: 0.8,
});
const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

// 補助要素
scene.add(new THREE.GridHelper(1, 10));        // グリッド
scene.add(new THREE.AxesHelper(0.3));          // 座標軸
scene.add(new THREE.AmbientLight(0x404040));   // 環境光
scene.add(new THREE.DirectionalLight(0xffffff, 0.8)); // 指向性光

// カメラ姿勢を推定結果から設定
camera.position.set(tx, ty, tz);
camera.rotation.set(rx, ry, rz);
```

#### T9: パフォーマンスモード画面

レイアウト:
```
┌────────────────────────────────┐
│  [← Back]  パフォーマンス       │
├────────────────────────────────┤
│                                │
│     Three.js レンダリング       │
│     (仮想立方体 + グリッド)     │
│                                │
│                                │
│                                │
│                                │
├────────────────────────────────┤
│ カメラ位置: (0.15, 0.20, 0.50) │
│ [キャリブレーションへ戻る]      │
└────────────────────────────────┘
```

---

## 6. 重要な技術的考慮事項

### 6.1 OpenCV.js ArUcoモジュールの可用性

OpenCV.jsの標準ビルド（CDN配布版）にはArUcoモジュールが含まれない可能性がある。その場合の対応方針:

1. **まず試す**: CDN版のopencv.jsをロードし、`cv.aruco` が存在するか確認
2. **代替1**: ArUco対応のカスタムビルド済みopencv.jsを探す（参考記事で使用されているものなど）
3. **代替2**: `js-aruco` ライブラリ（ピュアJS実装）+ 独自solvePnP実装
4. **代替3**: OpenCV.jsをEmscriptenで自前ビルド（ArUco contrib含む）

### 6.2 パフォーマンス最適化

- **解像度**: 検出用は640x480で処理し、表示用はネイティブ解像度を使用
- **フレームレート**: 検出処理は15〜30fpsを目標
- **Matオブジェクトの管理**: OpenCV.jsのMatはGC対象外のため、使用後に `.delete()` で明示的に解放
- **Web Worker**: 将来的にマーカー検出をWeb Workerに移行し、UIスレッドをブロックしない

### 6.3 iPad固有の対応

- **HTTPS必須**: カメラアクセスにはHTTPS環境が必要（開発時はlocalhost例外あり）
- **Safari対応**: `getUserMedia` のSafari固有の制約に注意
- **全画面表示**: `<meta name="apple-mobile-web-app-capable">` で全画面対応
- **画面回転**: landscape固定を推奨

### 6.4 座標系変換の注意点

OpenCV と Three.js では座標系の慣例が異なる:

| | OpenCV | Three.js |
|---|--------|----------|
| X軸 | 右 | 右 |
| Y軸 | **下** | **上** |
| Z軸 | **奥** | **手前** |

変換: OpenCVの (x, y, z) → Three.jsの (x, -y, -z)

---

## 7. 物理準備チェックリスト

### マーカーの印刷

- [ ] ArUco辞書 `DICT_4X4_50` からID 0〜4のマーカー画像を生成
- [ ] 各マーカーを9cm角で白い余白付き（上下左右1.5cm）で印刷
- [ ] 印刷サイズが正確か定規で確認

### 立方体の作成

- [ ] 12cm角の立方体を段ボール/発泡スチロールで作成
- [ ] 各面の中央にマーカーを貼付（底面以外の5面）
- [ ] マーカーの向き（上方向）を面ごとに正しく設定:
  - 正面(ID:0): マーカーの上辺が立方体の上を向く
  - 上面(ID:1): マーカーの上辺が立方体の奥（-Z）を向く
  - 右面(ID:2): マーカーの上辺が立方体の上を向く
  - 背面(ID:3): マーカーの上辺が立方体の上を向く
  - 左面(ID:4): マーカーの上辺が立方体の上を向く

### マーカー画像の生成方法

アプリケーション内にマーカー画像生成機能を実装するか、以下のオンラインツールを使用:
- OpenCVのPython環境で `cv2.aruco.generateImageMarker()` を使用
- または、アプリ内の「マーカー生成」ユーティリティページで生成・印刷

---

## 8. 将来の拡張（Phase 2 メモ）

Phase 2では以下の機能を追加予定:

1. **WebSocket/WebRTCによる端末間同期**: 各端末の姿勢データをサーバー経由で共有
2. **共通座標系の確立**: 全端末が同じマーカー立方体を見ることで自動的に統一される
3. **オブジェクトの同期レンダリング**: 全端末で同一の仮想オブジェクトを各視点からレンダリング
4. **マーカーフリー運用**: 初回キャリブレーション後はIMU（加速度・ジャイロ）でトラッキングを継続

---

## 9. 実装順序サマリー

```
Step 1: T1 (基盤整備) + T2 (OpenCV.jsローダー) + T3 (カメラアクセス)
           ↓
Step 2: T4 (マーカー検出) - ここで画面にマーカー検出結果を表示できるようにする
           ↓
Step 3: T5 (姿勢推定) + T6 (座標変換)
           ↓
Step 4: T7 (キャリブレーションモード画面) - 完全なキャリブレーション機能
           ↓
Step 5: T8 (Three.jsレンダリング)
           ↓
Step 6: T9 (パフォーマンスモード画面) - キャリブレーション結果を反映した3D表示
           ↓
Step 7: T10 (トップページ) + T11 (iPad最適化)
```

各ステップ完了後に動作確認を行い、問題がなければ次のステップに進む。
